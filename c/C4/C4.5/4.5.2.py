G = {"Адмиралтейская" :
    {"Садовая" : 4},
     "Садовая" :
         {"Сенная площадь" : 4,
          "Спасская" : 3,
          "Адмиралтейская" : 4,
          "Звенигородская" : 5},
     "Сенная площадь" :
         {"Садовая" : 4,
          "Спасская" : 4},
     "Спасская" :
         {"Садовая" : 4,
          "Сенная площадь" : 4,
          "Достоевская" : 6},
     "Звенигородская" :
         {"Пушкинская" : 3,
          "Садовая" : 5},
     "Пушкинская" :
         {"Звенигородская" : 3,
          "Владимирская" : 4},
     "Владимирская" :
         {"Достоевская" : 3,
          "Пушкинская" : 4},
     "Достоевская" :
         {"Владимирская" : 3,
          "Спасская" : 6}}
D: dict = {k : 100 for k in G.keys()}
U = {k : False for k in G.keys()}
start_k = "Адмиралтейская"
D[start_k] = 0
P = {k : None for k in G.keys()}
for _ in range(len(D)):
    # выбираем среди непросмотренных наименьшее по расстоянию
    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])

    for v in G[min_k].keys():  # проходимся по всем смежным вершинам
         if D[v] > D[min_k] + G[min_k][v]:  # если расстояние от текущей вершины меньше
            D[v] = D[min_k] + G[min_k][v]  # то фиксируем его
            P[v] = min_k  # и записываем как предок

    U[min_k] = True

pointer = input("Введите станцию назначения из списка G: ") # куда должны прийти
path = [] # список с вершинами пути
while pointer is not None: # перемещаемся, пока не придём в стартовую точку
    path.append(pointer)
    pointer = P[pointer]

path.reverse() # разворачиваем путь
for v in path:
    print(v)

print(D, U, sep="\n")
